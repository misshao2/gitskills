<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>图片懒加载</title>
</head>

<body>
</body>
<script>
var urls = [
    "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png",
    "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png",
    "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png",
    "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png",
    "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png",
    "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png"
];

function loadImg(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
            console.log("一张图片加载完成");
            resolve(img);
        };
        img.onerror = function() {
            reject(new Error('Could not load image at' + url));
        };
        img.src = url;
    });
}

function limitLoad(urls, handler, limit) {
    let sequence = [].concat(urls); // 复制urls
    // 这一步是为了初始化 promises 这个"容器"
    let promises = sequence.splice(0, limit).map((url, index) => {
        return handler(url).then(() => {
            // 返回下标是为了知道数组中是哪一项最先完成
            console.log(index);
            return index;
        });
    });
    // 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用
    return sequence
        .reduce((pCollect, url) => {
            return pCollect
                .then(() => {
                    return Promise.race(promises); // 返回已经完成的下标
                })
                .then(fastestIndex => { // 获取到已经完成的下标
                    // 将"容器"内已经完成的那一项替换
                    console.log("这是" + Promise + "最快" + fastestIndex);
                    console.log("这是" + promises);
                    promises[fastestIndex] = handler(url).then(
                        () => {
                            console.log("这是2" + promises);
                            console.log("这是zuikuai" + promises[fastestIndex]);
                            return fastestIndex; // 要继续将这个下标返回，以便下一次变量
                        }
                    );
                })
                .catch(err => {
                    console.error(err);
                });
        }, Promise.resolve()) // 初始化传入
        .then(() => { // 最后三个用.all来调用
            return Promise.all(promises);
        });
}
limitLoad(urls, loadImg, 3)
    .then(res => {
        console.log("图片全部加载完毕");
        console.log(res);
    })
    .catch(err => {
        console.error(err);
    });






var arr = [1, 2, 3, 4]


arr.reduce((p, value) => { return p.then(() => { return new Promise(resolve => { setTimeout(() => { resolve(console.log(value)) }, 1000) }) }) }, Promise.resolve())；

const arr = [1, 2, 3]
arr.reduce((p, x) => {
    return p.then(() => {
        return new Promise(r => {
            setTimeout(() => r(console.log(x)), 1000)
        })
    })
}, Promise.resolve())




function deepClone(obj) {
    if (obj !== 'null' && typeof obj === 'object') {
        let cloneObj = Array.isArray(obj) ? [] : {};
        let map = new weakMap();
        for (let prop in obj) {
            if (obj.hasOwnPrototype(prop)) {
                if (!map.has(prop)) {
                    map.set(prop) = true;
                    cloneObj[prop] = obj[prop];
                }

            }
        }
        return cloneObj;
    } else return obj;
}
</script>

</html>